# 搭建开发环境



```
export ARCH=arm
export PATH=$PATH:/home/book/jz2440/gcc-3.4.5-glibc-2.3.6/bin
arm-linux-gcc -v
```



ifconfig eth0 192.168.18.8
mount -t nfs -o intr,nolock,rsize=1024,wsize=1024 192.168.18.11:/home/book/nfs_rootfs/first_fs /mnt

kill -9 778

127.0.0.1    book     root     22



# led



![image-20210320232526452](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210320232526452.png)



![image-20210320232642917](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210320232642917.png)

nLED_1 ==> GPF4

nLED_2 ==> GPF5

nLED_4 ==> GPF6

nLED_8 ==> GPF7 (该LED灯接在网卡上，不用作用户灯)



![image-20210320232935443](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210320232935443.png)



![image-20210320232956474](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210320232956474.png)



![image-20210320233029870](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210320233029870.png)



![image-20210320233053215](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210320233053215.png)



## 启动过程



1. Nor启动：CPU从Nor Flash的0地址处读指令并执行
2. Nand启动：硬件将Nand Flash中的前4K字节的内容复制到内部SRAM中执行



## 编写LED程序



GPFCON : 0x00000100 [9:8] = 01 

GPFDAT : 0x0

 

led.S

```assembly

.text
.global _start

_start:

ldr r0, =0x56000050
ldr r1, =0x100 
str r1, [r0]

ldr r0, =0x56000054
mov r1, #0x0
str r1, [r0]

b .
```



led.dis

```assembly
00000000 <_start>:
   0:	e59f0014 	ldr	r0, [pc, #20]	; 1c <.text+0x1c>
   4:	e3a01c01 	mov	r1, #256	; 0x100
   8:	e5801000 	str	r1, [r0]
   c:	e59f000c 	ldr	r0, [pc, #12]	; 20 <.text+0x20>
  10:	e3a01000 	mov	r1, #0	; 0x0
  14:	e5801000 	str	r1, [r0]
  18:	eafffffe 	b	18 <_start+0x18>
  1c:	56000050 	undefined
  20:	56000054 	undefined
```

pc = 当前指令地址 + 8 （3级流水线机制）

ldr r0, [pc, #20] : 0 + 8 + 20 = 28 = 0x1c ==> 去地址0x1c的地方取值，即0x56000050, 将它存储在r0寄存器中

mov r1, #256 : 将数据0x100写入寄存器r1

str r1, [r0] : 将寄存器r1里面的值写入地址为r1的地方，即将0x100的值写入地址0x56000050中

。。。

注意：ldr r0, =0x56000050是一个伪指令，因为没有一个对应的指令能表示该操作。

若操作数是立即数，则会转换成mov指令：mov r1, #256.

若操作数不是立即数，上面的情况, 则会转换成寄存器间接寻址的方式，即：ldr r0, [pc, #20]

pc+20的地址存放的就是0x56000050。



led.bin

```
14 00 9f e5 01 1c a0 e3 00 10 80 e5 0c 00 9f e5
00 10 a0 e3 00 10 80 e5 fe ff ff ea 50 00 00 56
54 00 00 56
```

bin文件里面保存的就是机器码。



**MOV指令机器码 **

![image-20210321145619339](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210321145619339.png)

mov r0, #0x100 ==> e3a01c01

![image-20210321145915065](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210321145915065.png)



0x1 >> 24 = 0x100 ==> 0x1  << 8

0x1 << 10 = 0x400 ==> 0x1 >> 22 / 2 = 11 = bit[11:8]  = 1011

mov r0, #0x400 ==> e3a01b01

因此可以直接修改bin文件，点亮led2.



## 使用C语言编写LED程序



start.S

```assembly
.text
.global _start

_start:

    ldr sp, =4096    //nand启动

    bl main

halt:
    b halt
```



led.c

```c
int main()
{
    unsigned int *pGPFCON = (unsigned int*)0x56000050;
    unsigned int *pGPFDAT = (unsigned int*)0x56000054;

    *pGPFCON = 0x100;    // output
    *pGPFDAT = 0x0;      // output low

    return 0;
}
```



Makefile

```makefile
all:
	arm-linux-gcc -c -o led.o led.c
	arm-linux-gcc -c -o start.o start.S
	arm-linux-ld -Ttext 0 start.o led.o -o led.elf
	arm-linux-objcopy -O binary -S led.elf led.bin
	arm-linux-objdump -D led.elf > led.dis
clean:
	rm *.bin *.o *.elf *.dis
```



注意：在链接过程中，start.o一定要在led.o的前面。



led.dis

```assembly
00000000 <_start>:
   0:	e3a0da01 	mov	sp, #4096	; 0x1000
   4:	eb000000 	bl	c <main>

00000008 <halt>:
   8:	eafffffe 	b	8 <halt>

0000000c <main>:
   c:	e1a0c00d 	mov	ip, sp                          #ip = sp = 4096
  10:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}       #pc, lr, ip, fp (sp = 4080)
  14:	e24cb004 	sub	fp, ip, #4	; 0x4               #fp = ip - 4 = 4092
  18:	e24dd008 	sub	sp, sp, #8	; 0x8               #sp = sp - 8 = 4080 - 8 = 4072
  1c:	e3a03456 	mov	r3, #1442840576	; 0x56000000    #r3 = 0x56000000
  20:	e2833050 	add	r3, r3, #80	; 0x50              #r3 = r3 + 0x50 = 0x56000050
  24:	e50b3010 	str	r3, [fp, #-16]                  #[4092 - 16] = 0x56000050
  28:	e3a03456 	mov	r3, #1442840576	; 0x56000000    #r3 = 0x56000000
  2c:	e2833054 	add	r3, r3, #84	; 0x54              #r3 = r3 + 0x54 = 0x56000054
  30:	e50b3014 	str	r3, [fp, #-20]                  #[4092 - 20] = 0x56000054
  34:	e51b2010 	ldr	r2, [fp, #-16]                  #r2 = [fp - 16] = 0x56000050
  38:	e3a03c01 	mov	r3, #256	; 0x100             #r3 = 0x100
  3c:	e5823000 	str	r3, [r2]	                    #[0x56000050] = 0x100
  40:	e51b2014 	ldr	r2, [fp, #-20]                  #r2 = [fp - 20] = 0x56000054
  44:	e3a03000 	mov	r3, #0	; 0x0			        #r3 = 0x0
  48:	e5823000 	str	r3, [r2]                        #[0x56000054] = 0x0
  4c:	e3a03000 	mov	r3, #0	; 0x0                   #r3 = 0
  50:	e1a00003 	mov	r0, r3                          #r0 = r3 = 0 ==> return 0;
  54:	e24bd00c 	sub	sp, fp, #12	; 0xc               #sp = fp - 12 = 4080
  58:	e89da800 	ldmia	sp, {fp, sp, pc}            #fp = [4080] sp = [4084] pc = [4088]
  													    #fp = 4080  sp = 4096  pc = lr = 0x8
```



stmdb	sp!, {fp, ip, lr, pc} 

db: 先减后存，存放顺序：pc, lr, ip, fp  (高编号的寄存器先存)

！：sp的值为最后更新的sp的值



ldmia	sp, {fp, sp, pc}

ia : 先读后增



## 按键



![image-20210321215840731](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210321215840731.png)

EINT0 ==> GPF0

EINT2 ==> GPF2

EINT11 ==> GPG3





# 时钟体系



Mpll = (2*m * Fin) / (p * 2^s^)
m = M (the value for divider M)+ 8, p = P (the value for divider P) + 2



mrc p15,0,r0,c1,c0,0
orr r0,r0,#0xC0000000
mcr p15,0,r0,c1,c0,0



注意：要先设置异步模式，再设置MPLL

```c
void clock_init(void)
{
    /* 设置LOCKTIME */
    LOCKTIME = 0xFFFFFFFF;

    /* 设置分配系数，使得FCLK : HCLK : PCLK = 8 : 2 : 1 */
    CLKDIVN |= (2<<1) | (1<<0);

    /* 设置CPU工作于异步模式 */
    __asm
    (
        "mrc p15,0,r0,c1,c0,0; \
        orr r0,r0,#0xC0000000; \
        mcr p15,0,r0,c1,c0,0;"
    );

    // 设置完异步模式后再设置MPLL
    /* 设置MPLL,使得FCLK = 400MHz, HCLK = 100MHz, PCLK = 50MHz */
    MPLLCON = (92<<12) | (1<<4) | (1<<0);
}
```



# 串口



# SDRAM



BWSCON = 0x22000000

![image-20210326000635384](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210326000635384.png)

* DW6：数据宽度，32位
* WS6：WAIT信号，内存向2440发出的请求等待信号，不需要
* ST6：使能/禁止数据掩码引脚，对于SDRAM此位为0，对于SRAM，此为为1
  * SDRAM上有nWBE0~nWBE3共4个引脚用来决定写某个字节
  * SDRAM从一个地址上读取4个字节的数据到SDRAM控制器，然后挑选自己需要的数据即可，不用硬件屏蔽某个位



BANKCON6 = 0x18001

![image-20210326001829611](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210326001829611.png)

![image-20210326001842604](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210326001842604.png)

* MT：BANKCON6上接的是SDRAM
* Trcd：行地址到列地址的延时（20ns）

![image-20210326002412207](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210326002412207.png)

* SCAN：列地址占用的位数（9bit）

![image-20210326002700221](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210326002700221.png)



REFRESH

![image-20210326002948674](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210326002948674.png)

* REFEN：使能刷新（Enable）
* TREFMD：刷新模式（Auto Refresh）
* Trp：行地址预充电时间（20ns）

![image-20210326004213510](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210326004213510.png)

* Tsrc：Trc = Tsrc + Trp ==> Tsrc = Trc - Trp = 70 - 20 = 50ns

![image-20210326004440829](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210326004440829.png)

* Refresh Counter：刷新计数器

![image-20210326003313871](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210326003313871.png)

 64ms刷新8000次==> 刷新周期 = 64ms/8000 = 8us

Refresh Counter = 2^11^ + 1 - 100x8 = 1249



BANKSIZE

![image-20210326004810472](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210326004810472.png)

* BURST_EN：突发访问，一次可以连续访问多个字节（Enable）
* SCKE_EN：是否使能SDRAM掉电模式（Enable）
* SCLK_EN：SCLK只在SDRAM访问周期期间使能（Enable）
* BK76MAP：Bank6/7存储器映射，实际SDRAM的大小（64MB）



MRSRB6

![image-20210326005416099](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210326005416099.png)

* WBL：写突发长度
* TM：测试模式
* CL：列地址等待多长时间后读取数据 （2clocks）

![image-20210326005715693](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210326005715693.png)

* BT：突发类型（连续）
* BL：突发长度



# 重定位



连接脚本格式：

```
SECTIONS {
...
secname start BLOCK(align) (NOLOAD) : AT (ldadr)
	{contents} >region :phadr = fill
...
}
```



* secname: 段名
* start: 起始地址（运行时地址/重定位地址）
* ldadr: 加载地址
* contents: 内容，例如：*(.text) (存储顺序由makefile中文件的执行顺序一致)



```
SECTIONS{
    
    . = ALIGN(4);
    .text      :
    {
    *(.text)
    }

    . = ALIGN(4);
    .rodata : { *(.rodata) }

    . = ALIGN(4);
    .data 0x30000000 : AT(0x800) 
    { 
        data_load_addr = LOADADDR(.data);
        data_start = .;
        *(.data) 
        data_end = .;
    }

    . = ALIGN(4);
    __bss_start = .;
    .bss : { *(.bss) *(.COMMON) }
    __bss_end = .;
}
```



若加载地址不等于运行地址，对于elf文件，加载器（JTAG）帮我们实现重定位。对于.bin文件，需要我们手动实现重定位



```assembly
/* 重定位data段 */
    ldr r1, =data_load_addr
    ldr r2, =data_start
    ldr r3, =data_end

cpy:
    ldr r4, [r1]
    str r4, [r2]
    add r1, r1, #1
    add r2, r2, #1
    cmp r2, r3
    bne cpy
```



```assembly
30000060 <clean>:
30000060:	e5813000 	str	r3, [r1]
30000064:	e2811004 	add	r1, r1, #4	; 0x4
30000068:	e1510002 	cmp	r1, r2
3000006c:	dafffffb 	ble	30000060 <clean>
30000070:	eb000045 	bl	3000018c <led_init>
30000074:	e59ff010 	ldr	pc, [pc, #16]	; 3000008c <.text+0x8c>

30000078 <halt>:
30000078:	eafffffe 	b	30000078 <halt>
3000007c:	40001000 	andmi	r1, r0, r0
30000080:	30000000 	andcc	r0, r0, r0
30000084:	30000eac 	andcc	r0, r0, ip, lsr #29
30000088:	30000ead 	andcc	r0, r0, sp, lsr #29
3000008c:	300000c4 	andcc	r0, r0, r4, asr #1
```



因为sdram的初始化是根据100M的HCLK来初始化的，所以在start.S中调用bl sdram_init函数之前一定要先初始化时钟，不然SDRAM无法进行读写操作，当pc跳到SDRAM中执行时会发生错误。



目前重Nand启动的代码不能超过4K，因为cpu从Nand启动时会将Nand中的前4K字节复制到SRAM中运行，因为此时我们还没有对Nand进行初始化，所以不能将超过4K字节之后的代码拷贝到SDRAM中去。但Nor启动代码可以超过4K，因为NorFlash在运行前已经可以使用了，并且NorFlash可以像RAM那样地读，进而可以将所有的代码都拷贝到SDRAM中去运行。





# 异常与中断



7种模式：

1. Usr模式：正常模式
2. Sys模式：兴奋模式
3. Und模式：未定义指令异常模式
4. SVC模式：管理模式
5. Abt模式：终止模式（指令预取终止，数据访问终止）
6. IRQ模式：中断模式
7. FIQ模式：快中断模式

>  2，3，4，5，6，7为特权模式，可以自由切换。usr模式不可通过程序进入其它模式



![image-20210327195143164](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210327195143164.png)

ARM920T has a total of 37 registers



CPSR

![image-20210327204617202](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210327204617202.png)



![image-20210327213823675](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210327213823675.png)



异常处理流程（硬件）：

1. 保存下一条指令的地址到LR（R14）寄存器中，lr = pc + 4 / pc + 8
2. 将CPSR寄存器的值赋值给SPSR
3. 修改CPSR的M4:M0，进入异常模式
4. 跳到向量表



退出异常流程（硬件）：

1. 将LR寄存器里的值赋给pc，pc = lr - 4 / lr - 8

![image-20210327205514403](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210327205514403.png)

2. 将SPSR寄存器的值赋值给CPSR

3. 清除中断标志位



中断向量：

![image-20210327224948173](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210327224948173.png)



外部中断：

![image-20210327232823838](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210327232823838.png)



外部中断属于without sub-register, 因此不用设置SUBSRCPND和SUBMASK。

SRCPND：用来显示哪个中断产生了

![image-20210327233052826](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210327233052826.png)

INTMSK：用来屏蔽中断

![image-20210327233312165](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210327233312165.png)

PRIORITY：用来设置中断优先级

![image-20210327233515877](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210327233515877.png)

INTPND：用来显示当前正在发生的中断

![image-20210327233625475](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210327233625475.png)

INTOFFSET：用来显示INTPND中哪一位被设置为1

![image-20210327234024591](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210327234024591.png)





# NorFlash



# NandFlash



![image-20210328170332731](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210328170332731.png)



![image-20210328170451274](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210328170451274.png)



K9F2G08U0C:

![image-20210328170817961](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210328170817961.png)



![image-20210328171025500](C:\Users\Albert\AppData\Roaming\Typora\typora-user-images\image-20210328171025500.png)



TACLS = tcls - twp = 0ns

TWRPH0 = twp = 12ns

TWRPH1 = tclh = talh = 5ns



# LCD



lcd软件框架：



* lcd_test.c：最终测试程序
  * geometry.c：画线
  * font.c：写字
    * framebuffer.c：与lcd控制器配合使用，最终实现画点操作
      * lcd.c：lcd硬件抽象层
        * lcd_3.5.c：3.5寸的lcd驱动
        * lcd_4.3.c：4.3寸的lcd驱动
          * lcd_controller.c：lcd控制器的抽象层
            * s3c2440_lcd_controller.c：2440对应的lcd控制器
              * 硬件层





# uboot



uboot-1.1.6

1. 解压缩

   > tar xjf u-boot-1.1.6.tar.bz2

2. 打补丁

   > patch -p1 < ../u-boot-1.1.6_jz2440.patch

3. 配置

   > make 100ask24x0_config

4. 编译

   > make



Makefile分析：

==make 100ask24x0_config==

```makefile
100ask24x0_config	:	unconfig
	@$(MKCONFIG) $(@:_config=) arm arm920t 100ask24x0 NULL s3c24x0
	mkconfig      100ask24x0   arm arm920t 100ask24x0 NULL s3c24x0 
```

MKCONFIG  := $(SRCTREE)/mkconfig    

SRCTREE   := $(CURDIR)

==> MKCONFIG等于源码根目录下的mkconfig文件

$(@:config=) : 将目标（100ask24x0_config）字符串中的_config替换成空，即100ask24x0



```makefile
#mkconfig      100ask24x0   arm arm920t 100ask24x0 NULL s3c24x0
#  $0              $1        $2   $3        $4      $5     $6

[ "${BOARD_NAME}" ] || BOARD_NAME="$1"
```

如果BOARD_NAME为空，则BOARD_NAME = $1 ==> BOARD_NAME = "100ask24x0"



```makefile
if [ "$SRCTREE" != "$OBJTREE" ] ; then
	mkdir -p ${OBJTREE}/include
	mkdir -p ${OBJTREE}/include2
	cd ${OBJTREE}/include2
	rm -f asm
	ln -s ${SRCTREE}/include/asm-$2 asm
	LNPREFIX="../../include2/asm/"
	cd ../include
	rm -rf asm-$2
	rm -f asm
	mkdir asm-$2
	ln -s asm-$2 asm
else
	cd ./include
	rm -f asm
	ln -s asm-$2 asm
fi
```

第一行，如果SRCTREE不等于OBJTREE，执行下面的代码。

在Makefile中，SRCTREE   := $(CURDIR)  

OBJTREE		:= (if ​(BUILD_DIR),(BUILD_DIR),​(CURDIR)) 

> 如果BUIL_DIR不为空，那么OBJTREE = BUILD_DIR，否则OBJTREE  == CURDIR

```makefile
ifdef O
ifeq ("$(origin O)", "command line")
BUILD_DIR := $(O)
endif
endif
```

如果在编译命令里面加入参数 *O* （如make O=/dir）就把O后面的指定的值复制给变量BUILD_DIR，很明显我们在编译时并没有指定路径，所以BUILD_DIR为空。（BUILD_DIR为编译后的目标文件路径）

上面的代码经过判断后执行的是else分支：

>cd ./include
>rm -f asm
>ln -s asm-$2 asm    # ln -s asm-arm asm

创建一个链接文件asm指向asm-arm，以后可以用asm直接指代asm-arm。

例如#include <asm/types.h> <==> #include <asm-arm/types.h>



```makefile
if [ -z "$6" -o "$6" = "NULL" ] ; then
	ln -s ${LNPREFIX}arch-$3 asm-$2/arch
else
	ln -s ${LNPREFIX}arch-$6 asm-$2/arch  # ln -s arch-s3c24x0 asm-arm/arch
fi
```

如果6为空，这执行下面的语句，否则执行else分支。显然6不为空，执行**ln -s {LNPREFIX}arch-6 asm-​2/arch**

在asm-arm目录下建立一个arch链接文件，指向arch-s3c24x0.



```makefile
if [ "$2" = "arm" ] ; then
	rm -f asm-$2/proc
	ln -s ${LNPREFIX}proc-armv asm-$2/proc   # ln -s proc-armv asm-arm/proc
fi
```



```makefile
echo "ARCH   = $2" >  config.mk  #ARCH  =arm        放入新建的config.mk文件中
echo "CPU    = $3" >> config.mk  #CPU   =arm920t    追加到 config.mk文件中
echo "BOARD  = $4" >> config.mk  #BOARD =100ask24x0 追加到 config.mk文件中

#$5为空,不执行
[ "$5" ] && [ "$5" != "NULL" ] && echo "VENDOR = $5" >> config.mk

# SOC = s3c24x0 追加到 config.mk文件中
[ "$6" ] && [ "$6" != "NULL" ] && echo "SOC    = $6" >> config.mk
```

执行完上面的代码后，include/config.mk文件的内容为：

> ARCH  = arm
>
> CPU  = arm920t
>
> BOARD = 100ask24x0
>
> SOC  = s3c24x0



```makefile
if [ "$APPEND" = "yes" ]	# Append to existing config file
then
	echo >> config.h
else
	> config.h		# Create new config file
fi
echo "/* Automatically generated - do not edit */" >> config.h
echo "#include <configs/$1.h>" >> config.h
```

APPEND = no, 因此执行else分支

第5行：创建config.h文件

第7行：将/* Automatically generated - do not edit */添加到config.h中

第8行：将#include <configs/100ask24x0.h>添加到config.h中



Makefile文件

```makefile
include $(OBJTREE)/include/config.mk

OBJS = cpu/$(CPU)/start.o # OBJS = cpu/arm920t/start.o

LIBS  = lib_generic/libgeneric.a
LIBS += board/$(BOARDDIR)/lib$(BOARD).a # LIBS += board/100ask24x0/lib100ask24x0.a
LIBS += cpu/$(CPU)/lib$(CPU).a          # LIBS += cpu/arm920t/libarm920t.a
LIBS += cpu/$(CPU)/$(SOC)/lib$(SOC).a   # LIBS += cpu/arm920t/s3c24x0/libs3c24x0.a
LIBS += lib_$(ARCH)/lib$(ARCH).a        # LIBS += lib_arm/libarm.a
```

在编译配置文件时会创建config.mk文件，里面内容如下：

> ARCH  = arm
>
> CPU  = arm920t
>
> BOARD = 100ask24x0
>
> SOC  = s3c24x0



```makefile
ALL = $(obj)u-boot.srec $(obj)u-boot.bin $(obj)System.map $(U_BOOT_NAND)

all:		$(ALL)

$(obj)u-boot.bin:	$(obj)u-boot
		$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
		
$(obj)u-boot:		depend version $(SUBDIRS) $(OBJS) $(LIBS) $(LDSCRIPT)
		UNDEF_SYM=`$(OBJDUMP) -x $(LIBS) |sed  -n -e 's/.*\(__u_boot_cmd_.*\)/-               					 u\1/p'|sort|uniq`;\
		cd $(LNDIR) && $(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \
			--start-group $(__LIBS) --end-group $(PLATFORM_LIBS) \
			-Map u-boot.map -o u-boot		
```

make没有带任何参数，则默认执行的是make all。

all <== u-boot.bin <== u-boot <== line 8 

第9行展开：

> UNDEF_SYM=arm-linux-objdump -x lib_generic/libgeneric.a board/100ask24x0/lib100ask24x0.a cpu/arm920t/libarm920t.a cpu/arm920t/s3c24x0/libs3c24x0.a lib_arm/libarm.a fs/cramfs/libcramfs.a fs/fat/libfat.a fs/fdos/libfdos.a fs/jffs2/libjffs2.a fs/reiserfs/libreiserfs.a fs/ext2/libext2fs.a net/libnet.a disk/libdisk.a rtc/librtc.a dtt/libdtt.a drivers/libdrivers.a drivers/nand/libnand.a drivers/nand_legacy/libnand_legacy.a drivers/usb/libusb.a drivers/sk98lin/libsk98lin.a common/libcommon.a |sed  -n -e 's/.*\(__u_boot_cmd_.*\)/-u\1/p'|sort|uniq;\
>
> cd /home/book/jz2440/uboot/u-boot-1.1.6 && 
>
> arm-linux-ld -Bstatic -T /home/book/jz2440/uboot/u-boot-1.1.6/board/100ask24x0/u-boot.lds -Ttext 0x33F80000  $UNDEF_SYM cpu/arm920t/start.o \
>                 --start-group lib_generic/libgeneric.a board/100ask24x0/lib100ask24x0.a cpu/arm920t/libarm920t.a cpu/arm920t/s3c24x0/libs3c24x0.a lib_arm/libarm.a fs/cramfs/libcramfs.a fs/fat/libfat.a fs/fdos/libfdos.a fs/jffs2/libjffs2.a fs/reiserfs/libreiserfs.a fs/ext2/libext2fs.a net/libnet.a disk/libdisk.a rtc/librtc.a dtt/libdtt.a drivers/libdrivers.a drivers/nand/libnand.a drivers/nand_legacy/libnand_legacy.a drivers/usb/libusb.a drivers/sk98lin/libsk98lin.a common/libcommon.a --end-group  \
>                 -Map u-boot.map -o u-boot

LNDIR = /home/book/jz2440/uboot/u-boot-1.1.6

LD = arm-linux-ld

LDFLAGS = -Bstatic -T /home/book/jz2440/uboot/u-boot-1.1.6/board/100ask24x0/u-boot.lds -Ttext 0x33F80000

==config.mk==

```makefile
LDFLAGS += -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE) $(PLATFORM_LDFLAGS)
```

==board/100ask24x0/config.mk==

```makefile
TEXT_BASE = 0x33F80000    #从SDRAM的最高地址空出512K字节就是0x33F80000
```

__OBJS = cpu/arm920t/start.o

__LIBS = *.a



u-boot.lds

```makefile
ENTRY(_start)
SECTIONS
{
	. = 0x00000000;    // 0x33f80000

	. = ALIGN(4);
	.text      :
	{
	  cpu/arm920t/start.o	(.text)
      board/100ask24x0/boot_init.o (.text)
	  *(.text)
	}

	. = ALIGN(4);
	.rodata : { *(.rodata) }

	. = ALIGN(4);
	.data : { *(.data) }

	. = ALIGN(4);
	.got : { *(.got) }

	. = .;
	__u_boot_cmd_start = .;
	.u_boot_cmd : { *(.u_boot_cmd) }
	__u_boot_cmd_end = .;

	. = ALIGN(4);
	__bss_start = .;
	.bss : { *(.bss) }
	_end = .;
}
```

-Ttext 0x33F80000, 从链接文件可以知道，从0x33F80000地址开始存放程序文件，并且存放的顺序由链接文件决定。第一个存放的是cpu/arm920t/start.o的代码段，然后依次。。。



==cpu/arm920t/start.S==

```assembly
.globl _start
_start:	b       reset

reset:
	/*
	 * 设置CPU工作在SVC模式
	 */
	mrs	r0,cpsr
	bic	r0,r0,#0x1f
	orr	r0,r0,#0xd3
	msr	cpsr,r0
	
	/*
	 * 关闭看门狗
	 */
	ldr     r0, =pWTCON
	mov     r1, #0x0
	str     r1, [r0]
	
	/*
	 * 屏蔽所有中断
	 */
	mov	r1, #0xffffffff
	ldr	r0, =INTMSK
	str	r1, [r0]
# if defined(CONFIG_S3C2410)
	ldr	r1, =0x3ff
	ldr	r0, =INTSUBMSK
	str	r1, [r0]
# endif

	/*
	 * 设置时钟
	 */
	bl clock_init

	/*
	 * 如果程序从Nand启动, 上电时该程序被拷贝到SRAM中, 此时_start = 0.
	 * _TEXT_BASE = 0x33f80000
	 * 运行地址和加载地址不一致，需要重定位
	 */
	adr	r0, _start		     /* r0 <- current position of code   */
	ldr	r1, _TEXT_BASE		 /* test if we run from flash or RAM */
	cmp     r0, r1           /* don't reloc during debug         */
	blne	cpu_init_crit
	
cpu_init_crit:
	/*
	 * 清ICache、DCache
	 */
	mov	r0, #0
	mcr	p15, 0, r0, c7, c7, 0	/* flush v3/v4 cache */
	mcr	p15, 0, r0, c8, c7, 0	/* flush v4 TLB */

	/*
	 * disable MMU stuff and caches
	 */
	mrc	p15, 0, r0, c1, c0, 0
	bic	r0, r0, #0x00002300	@ clear bits 13, 9:8 (--V- --RS)
	bic	r0, r0, #0x00000087	@ clear bits 7, 2:0 (B--- -CAM)
	orr	r0, r0, #0x00000002	@ set bit 2 (A) Align
	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-Cache
	mcr	p15, 0, r0, c1, c0, 0

	/*
	 * before relocating, we have to setup RAM timing
	 * because memory timing is board-dependend, you will
	 * find a lowlevel_init.S in your board directory.
	 */
	mov	ip, lr
	bl	lowlevel_init
	mov	lr, ip
	mov	pc, lr
	
	/* 设置栈 */
stack_setup:
	ldr	r0, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */
	sub	r0, r0, #CFG_MALLOC_LEN	/* malloc area                      */
	sub	r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo                        */
	
	#ifdef CONFIG_USE_IRQ
	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)
	#endif
	sub	sp, r0, #12		/* leave 3 words for abort-stack    */
	
	/*
	 * 代码重定位
	 */
relocate:				/* relocate U-Boot to RAM	    */
	adr	r0, _start		/* r0 <- current position of code   */
	ldr	r1, _TEXT_BASE		/* test if we run from flash or RAM */
	cmp     r0, r1                  /* don't reloc during debug         */
	beq     clear_bss
	
	ldr	r2, _armboot_start
	ldr	r3, _bss_start
	sub	r2, r3, r2		/* r2 <- size of armboot            */
#if 1
	bl  CopyCode2Ram	/* r0: source, r1: dest, r2: size */
#else
	add	r2, r0, r2		/* r2 <- source end address         */

copy_loop:
	ldmia	r0!, {r3-r10}		/* copy from source address [r0]    */
	stmia	r1!, {r3-r10}		/* copy to   target address [r1]    */
	cmp	r0, r2			/* until source end addreee [r2]    */
	ble	copy_loop
#endif
#endif	/* CONFIG_SKIP_RELOCATE_UBOOT */

	/* 清除bss段 */
clear_bss:
	ldr	r0, _bss_start		/* find start of bss segment        */
	ldr	r1, _bss_end		/* stop here                        */
	mov 	r2, #0x00000000		/* clear                            */
    
clbss_l:
	str	r2, [r0]		/* clear loop...                    */
	add	r0, r0, #4
	cmp	r0, r1
	ble	clbss_l
	
	/* 调用_start_armboot */
	ldr	pc, _start_armboot
```



SDRAM：

| 33FFFFFF |  uboot |
| -------- | -----: |
| 33F80000 |  uboot |
|          | MALLOC |
|          |    GBL |
|          |    IRQ |
|          |    FIQ |
| sp->     |        |



==board/100ask24x0/lowlevel_init.S==

```assembly
.globl lowlevel_init
lowlevel_init:
	/* memory control configuration */
	/* make r0 relative the current location so that it */
	/* reads SMRDATA out of FLASH rather than memory ! */
	ldr     r0, =SMRDATA
	ldr	r1, _TEXT_BASE
	sub	r0, r0, r1
	ldr	r1, =BWSCON	/* Bus Width Status Controller */
	add     r2, r0, #13*4
0:
	ldr     r3, [r0], #4
	str     r3, [r1], #4
	cmp     r2, r0
	bne     0b

	/* everything is fine now */
	mov	pc, lr

	.ltorg
/* the literal pools origin */

SMRDATA:
    .word (0+(B1_BWSCON<<4)+(B2_BWSCON<<8)+(B3_BWSCON<<12)+(B4_BWSCON<<16)+(B5_BWSCON<<20)+(B6_BWSCON<<24)+(B7_BWSCON<<28)) 
    .word ((B0_Tacs<<13)+(B0_Tcos<<11)+(B0_Tacc<<8)+(B0_Tcoh<<6)+(B0_Tah<<4)+(B0_Tacp<<2)+(B0_PMC))
    .word ((B1_Tacs<<13)+(B1_Tcos<<11)+(B1_Tacc<<8)+(B1_Tcoh<<6)+(B1_Tah<<4)+(B1_Tacp<<2)+(B1_PMC))
    .word ((B2_Tacs<<13)+(B2_Tcos<<11)+(B2_Tacc<<8)+(B2_Tcoh<<6)+(B2_Tah<<4)+(B2_Tacp<<2)+(B2_PMC))
    .word ((B3_Tacs<<13)+(B3_Tcos<<11)+(B3_Tacc<<8)+(B3_Tcoh<<6)+(B3_Tah<<4)+(B3_Tacp<<2)+(B3_PMC))
    .word ((B4_Tacs<<13)+(B4_Tcos<<11)+(B4_Tacc<<8)+(B4_Tcoh<<6)+(B4_Tah<<4)+(B4_Tacp<<2)+(B4_PMC))
    .word ((B5_Tacs<<13)+(B5_Tcos<<11)+(B5_Tacc<<8)+(B5_Tcoh<<6)+(B5_Tah<<4)+(B5_Tacp<<2)+(B5_PMC))
    .word ((B6_MT<<15)+(B6_Trcd<<2)+(B6_SCAN))
    .word ((B7_MT<<15)+(B7_Trcd<<2)+(B7_SCAN))
    .word ((REFEN<<23)+(TREFMD<<22)+(Trp<<20)+(Trc<<18)+(Tchr<<16)+REFCNT)
    .word 0xb1
    .word 0x30
    .word 0x30
```

主要进行SDRAM初始化



_start_armboot ==> flash_init ==> nand_init ==> main_loop

==main_loop==

```c
s = getenv ("bootcmd");
run_command (s, 0);

//若启动时按了空格，则执行下面程序
run_command("menu", 0);
```

bootcmd = nand read.jffs2 0x30007FC0 kernel; bootm 0x30007FC0

上面的意思是将nand中的kernel分区（即内核）读到地址0x30007FC0 （SDRAM）中去，然后执行bootm 0x30007FC0,从该地址启动内核。

> device nand0 <nandflash0>, # parts = 4
>  #: name                        size                    offset             mask_flags
>  0: bootloader          0x00040000       0x00000000             0
>  1: params                0x00020000       0x00040000             0
>  2: kernel                  0x00200000        0x00060000             0
>  3: root                      0x0fda0000        0x00260000              0

从NandFlash的地址0x00060000读出0x00200000大小的数据到SDRAM的0x30007FC0 中。

==cmd_nand.c==

```c
int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
{
	...
    if (s != NULL && (!strcmp(s, ".jffs2") || !strcmp(s, ".e") || !strcmp(s, ".i"))) 
    {
        if (read) 
        {
            /* read */
            nand_read_options_t opts;
            memset(&opts, 0, sizeof(opts));
            opts.buffer = (u_char*) addr;
            opts.length = size;
            opts.offset = off;
            opts.quiet      = quiet;
            ret = nand_read_opts(nand, &opts);
        }
    }
      ...
}

```



==cmd_bootm.c==

```c
int do_bootm (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
    //1.根据头部信息将内核移动到合适的位置
    
    //2.设置启动参数，跳到入口地址
    do_bootm_linux();
}
```

uboot启动的内核文件格式为uImage, 他是由头部和真正的内核来决定的。头部包含加载地址和入口地址，如果真正的内核代码不在加载地址，需要重定位，然后从入口地址开始执行。

真正的内核加载地址是0x30008000，头部大小是64Byte，因此将uImage放在0x30007FC + 64 = 0x30008000。此时内核的地址和加载地址一样，不需要重定位了。



uboot命令：

bootm 0x30007FC0

```c
U_BOOT_CMD(
 	bootm,	CFG_MAXARGS,	1,	do_bootm,
 	"bootm   - boot application image from memory\n",
 	"[addr [arg ...]]\n    - boot application image stored in memory\n"
 	"\tpassing arguments 'arg ...'; when booting a Linux kernel,\n"
 	"\t'arg' can be the address of an initrd image\n"
#ifdef CONFIG_OF_FLAT_TREE
	"\tWhen booting a Linux kernel which requires a flat device-tree\n"
	"\ta third argument is required which is the address of the of the\n"
	"\tdevice-tree blob. To boot that kernel without an initrd image,\n"
	"\tuse a '-' for the second argument. If you do not pass a third\n"
	"\ta bd_info struct will be passed instead\n"
#endif
);

#define Struct_Section  __attribute__ ((unused,section (".u_boot_cmd")))
#define U_BOOT_CMD(name,maxargs,rep,cmd,usage,help) \
cmd_tbl_t __u_boot_cmd_##name Struct_Section = {#name, maxargs, rep, cmd, usage, help}
==>宏展开
    
cmd_tbl_t __u_boot_cmd_bootm __attribute__ ((unused,section (".u_boot_cmd"))) 
= {"bootm", CFG_MAXARGS, 1, do_bootm, usage, help}
```

上面的宏展开后就是定义一个cmd_tbl_t类型的结构体，结构体的属性是强制存放在.u_boot_cmd段。



## 自己动手写uboot



uboot必须要工作在svc模式！！！



# 内核分析



## 配置

执行make xxx_deconfig后会生成.config文件

执行make uImage后会将.config文件的内容转换成autoconf.h和auto.conf。其中，autoconf.h被源文件包含，auto.conf文件按被顶层Makefile包含，然后传递到子目录下的Makefile文件来指导子目录的文件进行编译。



## Makefile

make uImage (uImage在arch/arm/Makefile中定义)

uImage : vmlinux 

> uImage = 头部 + vmlinux

vmlinux: (vmlinux-lds) (vmlinux-init) (vmlinux-main) ​(kallsyms.o) FORCE



vmlinux-init := (head-y) (init-y)

> **head-y  := arch/arm/kernel/head.o arch/arm/kernel/init_task.o**
>
> init-y   := init/
>
> **init-y   := (patsubst %/, %/built-in.o, (init-y))  == init/built-in.o**



vmlinux-main := (core-y) (libs-y) (drivers-y) (net-y)

>core-y   := usr/
>
>core-y   += kernel/ mm/ fs/ ipc/ security/ crypto/ block/
>
>**core-y   := (patsubst %/, %/built-in.o, (core-y))  == usr/built-in.o kernel/built-in.o mm/built-in.o fs/built-in.o ipc/built-in.o security/built-in.o crypto/built-in.o block/built-in.o**
>
>libs-y   := lib/
>
>libs-y1   := (patsubst %/, %/lib.a, (libs-y))
>
>libs-y2   := (patsubst %/, %/built-in.o, (libs-y))
>
>**libs-y   := (libs-y1) (libs-y2)  == lib/lib.a lib/built-in.o**
>
>drivers-y  := drivers/ sound/
>
>**drivers-y  := (patsubst %/, %/built-in.o, ​(drivers-y))  == drivers/built-in.o sound/built-in.o**
>
>net-y    := net/
>
>**net-y    := (patsubst %/, %/built-in.o, ​(net-y))  == net/built-in.o**



vmlinux-lds := arch/$(ARCH)/kernel/vmlinux.lds



vmlinux: (vmlinux-lds) (vmlinux-init) (vmlinux-main) (kallsyms.o) FORCE

> ifdef CONFIG_HEADERS_CHECK
>
>   (Q)(MAKE) -f $(srctree)/Makefile headers_check
>
> endif
>
>   $(call if_changed_rule,vmlinux__)
>
>   (Q)(MAKE) -f (srctree)/scripts/Makefile.modpost @
>
>   $(Q)rm -f .old_version

分析vmlinux的执行过程有两种方法：1. 分析Makefile；2. 查看编译信息。

查看编译信息：在编译成功后执行rm vmlinux；make uImage V=1;

> arm-linux-ld -EL  -p --no-undefined -X -o vmlinux 
>
> -T arch/arm/kernel/vmlinux.lds 
>
> arch/arm/kernel/head.o arch/arm/kernel/init_task.o  init/built-in.o --start-group  usr/built-in.o  arch/arm/kernel/built-in.o  arch/arm/mm/built-in.o  arch/arm/common/built-in.o  arch/arm/mach-s3c2410/built-in.o  arch/arm/mach-s3c2400/built-in.o  arch/arm/mach-s3c2412/built-in.o  arch/arm/mach-s3c2440/built-in.o  arch/arm/mach-s3c2442/built-in.o  arch/arm/mach-s3c2443/built-in.o  arch/arm/nwfpe/built-in.o  arch/arm/plat-s3c24xx/built-in.o  kernel/built-in.o  mm/built-in.o  fs/built-in.o  ipc/built-in.o  security/built-in.o  crypto/built-in.o  block/built-in.o  arch/arm/lib/lib.a  lib/lib.a  arch/arm/lib/built-in.o  lib/built-in.o  drivers/built-in.o  sound/built-in.o  net/built-in.o 
>
> --end-group .tmp_kallsyms2.o

第一个文件：arch/arm/kernel/head.o

链接脚本：arch/arm/kernel/vmlinux.lds 



uboot：启动内核（最终目的）

内核：启动应用程序（最终目的）



内核：

1. 处理uboot传入的参数
   1. 判断是否支持这个CPU；
   2. 判断是否支持这个单板（根据uboot传入的机器ID：362）；
   3. 创建MMU页表；
   4. 使能MMU；
   5. 跳转到start_kernel执行（内核的第一个C函数）；
2. 挂接根文件系统
3. 启动应用程序



==arch/arm/kernel/head.S==

```assembly
bl	__lookup_machine_type		@ r5=machinfo
movs	r8, r5				    @ invalid machine (r5=0)?
beq	__error_a			        @ yes, error 'a'
bl	__create_page_tables        @创建页表
```

bl	__lookup_machine_type, 匹配传入的机器ID，若不匹配，则执行error分支进入死循环。

==__lookup_machine_type==(arch/arm/kernel/head-common.S)

```assembly
3:	.long	.
	.long	__arch_info_begin
	.long	__arch_info_end

__lookup_machine_type:
	adr	r3, 3b               @r3 = 3b的地址（物理地址）
	ldmia	r3, {r4, r5, r6} @r4 = . (label 3 的虚拟地址), r5 = __arch_info_begin, r6 =                                      __arch_info_end
	sub	r3, r3, r4			@ get offset between virt&phys 虚拟地址和物理地址的偏移量
	add	r5, r5, r3			@ convert virt addresses to 
	add	r6, r6, r3			@ physical address space
	@比较机器ID
1:	ldr	r3, [r5, #MACHINFO_TYPE]	@ get machine type
	teq	r3, r1				@ matches loader number?
	beq	2f				@ found
	add	r5, r5, #SIZEOF_MACHINE_DESC	@ next machine_desc
	cmp	r5, r6
	blo	1b
	mov	r5, #0				@ unknown machine
2:	mov	pc, lr
```

在链接脚本中有arch_info_begin和arch_info_end的定义：

```
__arch_info_begin = .;
*(.arch.info.init)
__arch_info_end = .;
```

include/asm-arm/mach/arch.h

```c
struct machine_desc {
	/*
	 * Note! The first four elements are used
	 * by assembler code in head-armv.S
	 */
	unsigned int		nr;		/* architecture number	*/  机器ID
	unsigned int		phys_io;	/* start of physical io	*/
	unsigned int		io_pg_offst;	/* byte offset for io 
						 * page tabe entry	*/

	const char		*name;		/* architecture name	*/
	unsigned long		boot_params;	/* tagged list		*/

	unsigned int		video_start;	/* start of video RAM	*/
	unsigned int		video_end;	/* end of video RAM	*/

	unsigned int		reserve_lp0 :1;	/* never has lp0	*/
	unsigned int		reserve_lp1 :1;	/* never has lp1	*/
	unsigned int		reserve_lp2 :1;	/* never has lp2	*/
	unsigned int		soft_reboot :1;	/* soft reboot		*/
	void			(*fixup)(struct machine_desc *,
					 struct tag *, char **,
					 struct meminfo *);
	void			(*map_io)(void);/* IO mapping function	*/
	void			(*init_irq)(void);
	struct sys_timer	*timer;		/* system tick timer	*/
	void			(*init_machine)(void);
};

#define MACHINE_START(_type,_name)			\
static const struct machine_desc __mach_desc_##_type	\
 __used							\
 __attribute__((__section__(".arch.info.init"))) = {	\
	.nr		= MACH_TYPE_##_type,		\
	.name		= _name,

#define MACHINE_END				\
};
```

arch/arm/mach-s3c2440/mach-smdk2440.c

```c
MACHINE_START(S3C2440, "SMDK2440")
	/* Maintainer: Ben Dooks <ben@fluff.org> */
	.phys_io	= S3C2410_PA_UART,
	.io_pg_offst	= (((u32)S3C24XX_VA_UART) >> 18) & 0xfffc,
	.boot_params	= S3C2410_SDRAM_PA + 0x100,

	.init_irq	= s3c24xx_init_irq,
	.map_io		= smdk2440_map_io,
	.init_machine	= smdk2440_machine_init,
	.timer		= &s3c24xx_timer,
MACHINE_END
    
==>
static const struct machine_desc __mach_desc_S3C2440	\
__used   \
__attribute__((__section__(".arch.info.init"))) = {	\  将该结构体放在.arch.info.init段
	.nr		= MACH_TYPE_S3C2440,		\    
    .name	= "SMDK2440",
    /* Maintainer: Ben Dooks <ben@fluff.org> */
    .phys_io	= S3C2410_PA_UART,
	.io_pg_offst	= (((u32)S3C24XX_VA_UART) >> 18) & 0xfffc,
	.boot_params	= S3C2410_SDRAM_PA + 0x100,

	.init_irq	= s3c24xx_init_irq,
	.map_io		= smdk2440_map_io,
	.init_machine	= smdk2440_machine_init,
	.timer		= &s3c24xx_timer,    
};                                            
```

==start_kernel （/init/main.c）==

```c
const char linux_banner[] =
	"Linux version " UTS_RELEASE " (" LINUX_COMPILE_BY "@"
	LINUX_COMPILE_HOST ") (" LINUX_COMPILER ") " UTS_VERSION "\n";

asmlinkage void __init start_kernel(void)
{
    printk(linux_banner);    //打印版本信息
    //处理启动参数
    setup_arch(&command_line);
    setup_command_line(command_line);
    
    rest_init(); 
    	kernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND);   //创建内核线程
    		kernel_init();
                prepare_namespace();
    				mount_root();    //挂接根文件系统 root=/dev/mtdblock3
    			init_post();  
}

//执行应用程序
static int noinline init_post(void)
{
    free_initmem();
	unlock_kernel();
	mark_rodata_ro();
	system_state = SYSTEM_RUNNING;
	numa_default_policy();

	if (sys_open((const char __user *) "/dev/console", O_RDWR, 0) < 0)
		printk(KERN_WARNING "Warning: unable to open an initial console.\n");

	(void) sys_dup(0);
	(void) sys_dup(0);

	if (ramdisk_execute_command) {
		run_init_process(ramdisk_execute_command);
		printk(KERN_WARNING "Failed to execute %s\n",
				ramdisk_execute_command);
	}

	/*
	 * We try each of these until one succeeds.
	 *
	 * The Bourne shell can be used instead of init if we are
	 * trying to recover a really broken machine.
	 */
	if (execute_command) {
		run_init_process(execute_command);
		printk(KERN_WARNING "Failed to execute %s.  Attempting "
					"defaults...\n", execute_command);
	}
	run_init_process("/sbin/init");
	run_init_process("/etc/init");
	run_init_process("/bin/init");
	run_init_process("/bin/sh");

	panic("No init found.  Try passing init= option to kernel.");
}
```

> Linux version 2.6.22.6 (root@book-virtual-machine) (gcc version 3.4.5) #1 Tue May 15 19:57:22 CST 2018

setup_arch （arm/arm/kernel/setup.c）

```c
void __init setup_arch(char **cmdline_p)
{
	struct tag *tags = (struct tag *)&init_tags;
	struct machine_desc *mdesc;
	char *from = default_command_line;
    
    setup_processor();    //打印CPU架构信息
    
    mdesc = setup_machine(machine_arch_type);    // printk("Machine: %s\n", list->name);
    
    if (mdesc->boot_params)    //S3C2410_SDRAM_PA + 0x100 = 0x30000100
		tags = phys_to_virt(mdesc->boot_params);
    
    //解析tag
    parse_tags(tags);
    
    //解析cmdline: "noinitrd root=/dev/mtdblock3 init=/linuxrc console=ttySAC0"
    parse_cmdline(cmdline_p, from);
}
```

 

```c
setup_processor():
printk("CPU: %s [%08x] revision %d (ARMv%s), cr=%08lx\n",
	       cpu_name, processor_id, (int)processor_id & 15,
	       proc_arch[cpu_architecture()], cr_alignment);

setup_machine(machine_arch_type):
printk("Machine: %s\n", list->name);
```

> CPU: ARM920T [41129200] revision 0 (ARMv4T), cr=c0007177
>
> Machine: SMDK2440



分区表：（arch/arm/plat-s3c24xx/common-smdk.c）

```c
static struct mtd_partition smdk_default_nand_part[] = {
	[0] = {
        .name   = "bootloader",
        .size   = 0x00040000,
		.offset	= 0,
	},
	[1] = {
        .name   = "params",
        .offset = MTDPART_OFS_APPEND,
        .size   = 0x00020000,
	},
	[2] = {
        .name   = "kernel",
        .offset = MTDPART_OFS_APPEND,
        .size   = 0x00200000,
	},
	[3] = {
        .name   = "root",
        .offset = MTDPART_OFS_APPEND,
        .size   = MTDPART_SIZ_FULL,
	}
};
```



搭建Linux环境：uboot、linux kernel、rootfs



init_post:

```c
sys_open((const char __user *) "/dev/console", O_RDWR, 0);    //打开终端文件

sys_dup(0);

sys_dup(0);

run_init_process(execute_command);    // init=/linuxrc 启动/linuxrc程序

// 若命令行没有定义init=xxx, 则执行下面的程序
run_init_process("/sbin/init");    // 若正确执行，则不会返回；若错误执行，则紧接着执行下一个函数。
run_init_process("/etc/init");
run_init_process("/bin/init");
run_init_process("/bin/sh");
```



init进程：

1. 读取配置文件
2. 解析配置文件
3. 执行用户程序



/init/init.c

```c
int init_main(int argc, char **argv)
{
    .....
    parse_inittab();
    	file = fopen(INITTAB, "r");   // 打开配置文件/etc/inittab
        // 1.创建一个init_action结构,并填充; 2.把这个结构放入init_action_list链表
    	new_init_action();  
    
    run_actions(SYSINIT);
    	waitfor(a, 0);            // 执行应用程序，等待它执行完毕
    		run(a);                         // 创建process子进程
    		waitpid(runpid, &status, 0);    // 等待它结束
		delete_init_action(a);    // 将该结构从链表中删除
    
    run_actions(WAIT);
    	waitfor(a, 0);            // 执行应用程序，等待它执行完毕
    		run(a);                         // 创建process子进程
    		waitpid(runpid, &status, 0);    // 等待它结束
		delete_init_action(a);    // 将该结构从链表中删除
    
    run_actions(ONCE);
    	run(a);                         // 创建process子进程
    	delete_init_action(a);    // 将该结构从链表中删除
    
    while (1) {
        run_actions(RESPAWN);
        	if (a->pid == 0) {
					a->pid = run(a);
			}
        
        run_actions(ASKFIRST);
        	if (a->pid == 0) {
					a->pid = run(a);
                		"\nPlease press Enter to activate this console. ";
                		while (read(0, &c, 1) == 1 && c != '\n');    // 等待回车
			}
        
        wpid = wait(NULL);    // 等待子进程退出
        
        while (wpid > 0) {
            a->pid = 0;     // 退出后, 就设置pid = 0;
        }
    }
}
```

> inittab格式：
>
> <id>:<runlevels>:<action>:<process>
>
> id => /dev/id.  用作终端：stdin, stdout, stderr, printf, scanf, err
>
> runlevels: 忽略
>
> action: 执行时机
>
> process: 应用程序或脚本

若没有定义inittab文件，则会生成默认的配置项：

```c
new_init_action(CTRLALTDEL, "reboot", "");
new_init_action(SHUTDOWN, "umount -a -r", "");
new_init_action(RESTART, "init", "");
new_init_action(ASKFIRST, bb_default_login_shell, "");
new_init_action(ASKFIRST, bb_default_login_shell, VC_2);
new_init_action(ASKFIRST, bb_default_login_shell, VC_3);
new_init_action(ASKFIRST, bb_default_login_shell, VC_4);
new_init_action(SYSINIT, INIT_SCRIPT, "");

==> inittab格式 <id>:<runlevels>:<action>:<process>
::ctrlaltdel:reboot
::shutdown:umount -a -r
::restart:init
::askfirst:-/bin/sh
tty2::askfirst:-/bin/sh
tty3::askfirst:-/bin/sh
tty4::askfirst:-/bin/sh
::sysinit:/etc/init.d/rcs    
```



最小根文件系统：

1. /dev/console  /dev/null
2. busybox
3. /etc/inittab
4. 配置文件指定的应用程序
5. C库



配置、编译busybox：

make menuconfig

make 

make CONFIG_PREFIX=~/nfs_rootfs/first_fs/ install



NFS: jz2440开发板只支持桥接网络，不支持NAT网络

noinitrd root=/dev/mtdblock3 init=/linuxrc console=ttySAC0,115200



set bootargs noinitrd root=/dev/nfs nfsroot=192.168.18.11:/home/book/nfs_rootfs/first_fs ip=192.168.18.8 init=/linuxrc console=ttySAC0,115200



set bootargs noinitrd root=/dev/nfs nfsroot=192.168.18.11:/home/book/nfs_rootfs/first_fs ip=192.168.18.8 :192.168.9.2:192.168.9.6:255.255.255.0::eth0:off init=/linuxrc console=ttySAC0,115200




ifconfig eth0 192.168.18.8

mount -t nfs -o intr,nolock,rsize=1024,wsize=1024 192.168.18.11:/home/book/nfs_rootfs/first_fs /mnt



/home/book/nfs_rootfs/first_fs



# 按键驱动



exec 5</dev/mybuttons

打开设备文件/dev/mybuttons并将其关联到文件描述符5，以后就可以通过描述符5来访问设备mybuttons

相当于执行了open("/dev/mybuttons", O_RDWR);

exec 5<&-

取消关联



cat /proc/interrupts

显示所有注册的中断



./drvtest : 让应用程序在后天运行



ps: 显示当前所有进程



top: 参看进程所占用的资源，按q退出



## poll机制



## 异步通知



kill -USR1 PID / kill -10 PID : 发生信号量给应用程序

kill -9 PID : 杀死进程



VSCode ：设置 --> C_Cpp.errorSquiggles --> Disable : 关闭错误



























